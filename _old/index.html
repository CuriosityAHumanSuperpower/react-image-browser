<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>React Image Browser (Local)</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/react-bootstrap@2.7.4/dist/react-bootstrap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <!-- HEIC conversion removed for now; .heic files will show a filename placeholder -->

    <script type="text/babel">
    // -------------------------------
    // React imports & bootstrap alias
    // -------------------------------
    // Pull commonly used React hooks into local scope for convenience.
    const {useState, useEffect, useRef, useMemo} = React;
    // Alias React-Bootstrap as RB to keep JSX concise.
    const RB = ReactBootstrap;

    /*
      High-level file structure:
      - helper hook: useResizeCols
      - application state (useState declarations)
      - file handling: handleFiles/onFolderInput
      - selection helpers: selectRange, toggleSelect, selectAllToggle
      - actions: downloadSelected, copyToClipboard
      - lazy-load sentinel observer
      - modal navigation + keyboard handling
      - render: Navbar, Offcanvas (folders), Modal, Footer actions
    */

    // Responsive helper: set number of columns based on window width.
    // Keeps the grid responsive without extra layout libraries.
    function useResizeCols(setCols){
      useEffect(()=>{
        function update(){
          const w = window.innerWidth;
          if(w<=480) setCols(1);
          else if(w<=768) setCols(2);
          else if(w<=992) setCols(3);
          else if(w<=1200) setCols(4);
          else setCols(5);
        }
        update();
        window.addEventListener('resize',update);
        return ()=>window.removeEventListener('resize',update);
      },[setCols]);
    }

      // NOTE: HEIC detection/conversion removed. .heic/.heif files will be added as placeholders.

    // Main application component
    function App(){
      // folders: array of { name, files: [{file,url,name,folderPath,placeholder}], displayed }
      const [folders, setFolders] = useState([]);
      // search query used to filter filenames in the UI
      const [query, setQuery] = useState('');
      // root path detected from webkitRelativePath values (best-effort)
      const [selectedRootPath, setSelectedRootPath] = useState('');
      // number of columns in the gallery grid (responsive)
      const [cols, setCols] = useState(5);
      // UI theme: 'light' or 'dark' (defaults to dark per user preference)
      const [theme, setTheme] = useState('dark');
      // selected: Set of image URLs currently selected by the user
      const [selected, setSelected] = useState(new Set());
      // UI state: show/hide the folder offcanvas
      const [showOffcanvas, setShowOffcanvas] = useState(false);
      // modalImg: the currently opened image entry in the modal
      const [modalImg, setModalImg] = useState(null);
      // lastSelectedUrl: used for shift-range selections
      const [lastSelectedUrl, setLastSelectedUrl] = useState(null);
      // sentinelRefs: map of folderName -> sentinel element used by IntersectionObserver
      const sentinelRefs = useRef(new Map());
      // hidden file input ref to open the folder picker programmatically
      const fileInputRef = useRef(null);

      function openFilePicker(){ if(fileInputRef.current) fileInputRef.current.click(); }

      useResizeCols(setCols);

      useEffect(()=>{ document.documentElement.style.setProperty('--cols', cols); },[cols]);
      // set CSS var for navbar height so sticky headers can offset correctly
      useEffect(()=>{
        const nav = document.querySelector('.navbar');
        if(nav){
          const h = nav.offsetHeight || 56;
          document.documentElement.style.setProperty('--navbar-height', h + 'px');
        }
      },[]);
      useEffect(()=>{
        // apply theme to body and set a document-level data attribute so portalled elements (modals) pick up the theme
        if(theme==='dark'){
          document.body.classList.add('dark');
          document.documentElement.setAttribute('data-bs-theme','dark');
        } else {
          document.body.classList.remove('dark');
          document.documentElement.setAttribute('data-bs-theme','light');
        }
      },[theme]);

      // global keyboard handlers: Ctrl/Cmd + A => select all, Esc => clear selection
      useEffect(()=>{
        function onKey(e){
          const key = e.key || '';
          if((e.ctrlKey || e.metaKey) && key.toLowerCase() === 'a'){
            e.preventDefault();
            const s = new Set();
            folders.forEach(f=>f.files.forEach(it=>s.add(it.url)));
            setSelected(s);
            return;
          }
          if(key === 'Escape'){
            setSelected(new Set());
            setLastSelectedUrl(null);
          }
        }
        window.addEventListener('keydown', onKey);
        return ()=> window.removeEventListener('keydown', onKey);
      },[folders]);

      // Handle files selected by the user. Groups files by folder and creates
      // entries with object URLs. For .heic/.heif we currently create a
      // filename placeholder SVG rather than attempting conversion.
      async function handleFiles(fileList){
        // Accept images; for .heic/.heif we create a visual placeholder (we'll handle conversion later)
        const incoming = Array.from(fileList).filter(f=> f.type.startsWith('image') || /\.(heic|heif)$/i.test(f.name));
        const map = new Map();
        const relPaths = [];
        incoming.forEach(f=>{
          const full = f.webkitRelativePath || f.name;
          const parts = full.split('/');
          const folder = parts.length>1 ? parts.slice(0,-1).join('/') : '/';
          const name = parts[parts.length-1];
          let url;
          let entry;
          if(/\.(heic|heif)$/i.test(name)){
            // create a simple SVG placeholder that shows the filename (no conversion)
            const short = name.length > 24 ? name.slice(0,20) + '...' : name;
            const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='400' height='300'><rect fill='#0e1113' width='100%' height='100%'/><text x='50%' y='50%' fill='#dfe8ef' font-family='Roboto, Arial, sans-serif' font-size='14' text-anchor='middle' dominant-baseline='middle'>${short}</text></svg>`;
            url = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
            entry = {file:f,url,name,folderPath:folder,placeholder:true};
          } else {
            url = URL.createObjectURL(f);
            entry = {file:f,url,name,folderPath:folder};
          }
          if(!map.has(folder)) map.set(folder,[]);
          map.get(folder).push(entry);
          if(f.webkitRelativePath) relPaths.push(f.webkitRelativePath);
        });
        const arr = Array.from(map.entries()).map(([k,v])=>({name:k, files:v, displayed: Math.min(30,v.length)}));
        arr.sort((a,b)=>a.name.localeCompare(b.name));
        setFolders(arr);
        setSelected(new Set());
        // compute common relative root path among webkitRelativePath values (best-effort)
        let common = '';
        if(relPaths.length){
          const splitPaths = relPaths.map(p=>p.split('/'));
          const minLen = Math.min(...splitPaths.map(s=>s.length));
          let i = 0;
          while(i < minLen){
            const seg = splitPaths[0][i];
            if(splitPaths.every(sp=>sp[i]===seg)) i++; else break;
          }
          common = splitPaths[0].slice(0,i).join('/');
        }
        setSelectedRootPath(common || '');
      }

      function onFolderInput(e){ handleFiles(e.target.files); }

      // Select a contiguous range between two URLs (used for Shift+click behavior)
      function selectRange(fromUrl, toUrl){
        // Build flattened list and compute indexes
        const allFiles = [];
        folders.forEach(f => f.files.forEach(it => allFiles.push(it.url)));
        const fromIdx = allFiles.indexOf(fromUrl);
        const toIdx = allFiles.indexOf(toUrl);
        if(fromIdx === -1 || toIdx === -1) return;
        const start = Math.min(fromIdx, toIdx);
        const end = Math.max(fromIdx, toIdx);
        const newSelected = new Set(selected);
        for(let i = start; i <= end; i++){
          newSelected.add(allFiles[i]);
        }
        setSelected(newSelected);
        setLastSelectedUrl(toUrl);
      }

      function toggleSelect(url, keepSelection=false){
        setSelected(prev => {
          const s = new Set(prev);
          if(keepSelection && s.has(url)){ s.delete(url); }
          else if(!keepSelection){ s.clear(); s.add(url); }
          else{ s.add(url); }
          return s;
        });
        setLastSelectedUrl(url);
      }

      function selectAllToggle(checked){
        if(checked){
          const s = new Set();
          folders.forEach(f=>f.files.forEach(it=>s.add(it.url)));
          setSelected(s);
        } else setSelected(new Set());
      }

      // Download selected images as a ZIP. Placeholder entries (.heic) are skipped.
      async function downloadSelected(){
        if(selected.size===0){ alert('No images selected'); return; }
        const zip = new JSZip();
        const folder = zip.folder('images');
        const items = [];
        // collect selected items (flatten folders)
        for(const f of folders){ for(const it of f.files){ if(selected.has(it.url)) items.push(it); } }
        // add binary files to the ZIP; skip placeholders
        for(const it of items){ if(it.placeholder) continue; const buf = await it.file.arrayBuffer(); folder.file(it.name, buf); }
        const content = await zip.generateAsync({type:'blob'});
        const url = URL.createObjectURL(content);
        const a = document.createElement('a'); a.href = url; a.download = 'selected-images.zip'; document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      }

      // Copy selected images to the system clipboard (if supported).
      // Placeholders are excluded.
      async function copyToClipboard(){
        try{
          if(!navigator.clipboard || !navigator.clipboard.write) throw new Error('Clipboard API not supported for images');
          const items = [];
          for(const f of folders){
            for(const it of f.files){
              if(selected.has(it.url) && !it.placeholder){
                const blob = await it.file.slice(0, it.file.size, it.file.type);
                items.push(new ClipboardItem({[it.file.type]: blob}));
              }
            }
          }
          if(items.length===0){ alert('No images selected'); return; }
          await navigator.clipboard.write(items);
          alert('Copied selected images to clipboard (if supported by your browser).');
        }catch(err){
          // If clipboard write isn't available, fall back to the ZIP download flow.
          alert('Copy to clipboard not available. Falling back to ZIP download.');
          downloadSelected();
        }
      }

      useEffect(()=>{
    const obs = new IntersectionObserver((entries)=>{
          entries.forEach(ent=>{
            if(ent.isIntersecting){
              const id = ent.target.dataset.folder;
              setFolders(prev=>prev.map(f=>{
                if(f.name===id){ const newCount = Math.min(f.files.length, f.displayed + 30); return {...f, displayed:newCount}; }
                return f;
              }));
            }
          });
        },{rootMargin:'200px'});
        sentinelRefs.current.forEach((el)=>{ if(el) obs.observe(el); });
        return ()=> obs.disconnect();
      },[folders]);

      function registerSentinel(folder, el){ if(!el) sentinelRefs.current.delete(folder); else sentinelRefs.current.set(folder, el); }

      function filteredFiles(f){ if(!query) return f; const q = query.toLowerCase(); return f.filter(it => it.name.toLowerCase().includes(q)); }

      // Flattened list of visible files (respecting current query filter)
      const visibleFiles = useMemo(()=>{
        const arr = [];
        folders.forEach(f=>{
          const list = filteredFiles(f.files);
          list.forEach(it=>arr.push(it));
        });
        return arr;
      },[folders, query]);

      const [modalIndex, setModalIndex] = useState(null);

      function openModalAt(item){
        const idx = visibleFiles.findIndex(x=>x.url===item.url);
        const i = idx === -1 ? 0 : idx;
        setModalIndex(i);
        setModalImg(visibleFiles[i]);
      }

      function showNext(){
        if(!visibleFiles.length) return;
        const next = modalIndex === null ? 0 : (modalIndex + 1) % visibleFiles.length;
        setModalIndex(next);
        setModalImg(visibleFiles[next]);
      }

      function showPrev(){
        if(!visibleFiles.length) return;
        const prev = modalIndex === null ? visibleFiles.length - 1 : (modalIndex - 1 + visibleFiles.length) % visibleFiles.length;
        setModalIndex(prev);
        setModalImg(visibleFiles[prev]);
      }

      // Keyboard left/right navigation when modal open (Arrow keys navigate images)
      useEffect(()=>{
        function onKeyNav(e){
          if(!modalImg) return;
          if(e.key === 'ArrowLeft'){ e.preventDefault(); showPrev(); }
          if(e.key === 'ArrowRight'){ e.preventDefault(); showNext(); }
        }
        window.addEventListener('keydown', onKeyNav);
        return ()=> window.removeEventListener('keydown', onKeyNav);
      },[modalImg, visibleFiles, modalIndex]);

      function openFolderAnchor(name){
        // close offcanvas first, then scroll after it hides to avoid jumping to top
        setShowOffcanvas(false);
        setTimeout(()=>{
          const id = encodeURIComponent(name);
          const el = document.getElementById('folder-'+id);
          if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
        }, 260);
      }

      return (
        <div data-bs-theme={theme}>
          <RB.Navbar bg="light" expand="lg" className="mb-3 sticky-top shadow-sm navbar">
            <div className="container-fluid">
              <RB.Navbar.Brand href="#">Local Images Browser</RB.Navbar.Brand>
              <RB.Navbar.Toggle aria-controls="nav" />
              <RB.Navbar.Collapse id="nav">
                <RB.Nav className="me-auto">
                </RB.Nav>
                {/* top navbar theme controls removed (theme available in Actions dropdown) */}
                <div className="d-flex align-items-center">
                  <div className="btn-group btn-group-sm me-2" role="group" aria-label="Browse and folders">
                    <RB.Button variant="outline-secondary" size="sm" onClick={openFilePicker} aria-label="Browse a folder">Browse</RB.Button>
                    <RB.Button
                      variant="outline-secondary"
                      size="sm"
                      onClick={()=>setShowOffcanvas(true)}
                      aria-label="Folders"
                      disabled={folders.length === 0}
                      title={folders.length === 0 ? 'Load a folder first' : 'Open folders list'}
                    >
                      Folders
                    </RB.Button>
                  </div>
                  <input ref={fileInputRef} type="file" webkitdirectory="" directory="" multiple style={{display:'none'}} onChange={onFolderInput} />
                </div>
              </RB.Navbar.Collapse>
            </div>
          </RB.Navbar>

          {selectedRootPath && (
            <div className="container">
              <div className="small text-muted mb-2">Selected folder: {selectedRootPath}</div>
            </div>
          )}

          <div className="container" onClick={(e)=>{ if(e.target === e.currentTarget && !e.ctrlKey && !e.metaKey && !e.shiftKey) { setSelected(new Set()); setLastSelectedUrl(null); } }}>
            {folders.length===0 && (
              <div className="alert alert-info">No images loaded. Use the <button type="button" className="btn btn-link p-0 align-baseline" onClick={openFilePicker}>folder button</button> to pick images. Works offline and runs from this file.</div>
            )}
            {folders.map(folder=>{
              const id = encodeURIComponent(folder.name);
              const files = filteredFiles(folder.files).slice(0, folder.displayed);
              return (
                <div key={folder.name} id={'folder-'+id}>
                  <h5 className="folder-title">{folder.name} <small className="text-muted">({folder.files.length})</small></h5>
                      <div className="gallery mb-3" onClick={(e)=>{ if(e.target === e.currentTarget && !e.ctrlKey && !e.metaKey && !e.shiftKey) { setSelected(new Set()); setLastSelectedUrl(null); } }}>
                    {files.map(it=> (
                      <div className={`thumb ${selected.has(it.url)?'selected':''}`} key={it.url}
                        onClick={(e)=>{ 
                          e.stopPropagation(); 
                          if(e.ctrlKey || e.metaKey){ 
                            // Ctrl/Cmd: toggle selection
                            setSelected(prev => {
                              const s = new Set(prev);
                              if(s.has(it.url)) s.delete(it.url); else s.add(it.url);
                              return s;
                            });
                            setLastSelectedUrl(it.url);
                          } else if(e.shiftKey){
                            // Shift: if we have a last selected, select range, otherwise select this one
                            if(lastSelectedUrl){
                              selectRange(lastSelectedUrl, it.url);
                            } else {
                              setSelected(prev => {
                                const s = new Set(prev);
                                s.add(it.url);
                                return s;
                              });
                              setLastSelectedUrl(it.url);
                            }
                          } else {
                            // Plain click: open modal at this item (so navigation works)
                            openModalAt(it);
                          }
                        }}
                      >
                        <img src={it.url} loading="lazy" alt={it.name} />
                      </div>
                    ))}
                  </div>
                  <div ref={el=>registerSentinel(folder.name, el)} data-folder={folder.name} style={{height:1}}></div>
                </div>
              );
            })}
          </div>

          <RB.Offcanvas show={showOffcanvas} onHide={()=>setShowOffcanvas(false)} placement="end">
            <RB.Offcanvas.Header closeButton>
              <RB.Offcanvas.Title>üìÇ Folders</RB.Offcanvas.Title>
            </RB.Offcanvas.Header>
            <RB.Offcanvas.Body>
              <div className="list-group">
                {folders.map(f=> {
                  const id = encodeURIComponent(f.name);
                  return (
                    <a key={f.name} href={`#folder-${id}`} className="list-group-item list-group-item-action folder-link" onClick={()=>setShowOffcanvas(false)}>{f.name} <span className="text-muted">({f.files.length})</span></a>
                  );
                })}
              </div>
            </RB.Offcanvas.Body>
          </RB.Offcanvas>

          <RB.Modal show={!!modalImg} onHide={()=>{ setModalImg(null); setModalIndex(null); }} fullscreen centered>
              <RB.Modal.Header closeButton>
                <RB.Modal.Title>{modalImg?.name}</RB.Modal.Title>
              </RB.Modal.Header>
              <RB.Modal.Body className="modal-image-body">
                <div className="modal-image-wrap">
                  <div className="nav-zone left" onClick={showPrev} aria-hidden="true"></div>
                  {modalImg && <img src={modalImg.url} alt={modalImg.name} />}
                  <div className="nav-zone right" onClick={showNext} aria-hidden="true"></div>
                </div>
              </RB.Modal.Body>
          </RB.Modal>

          <div className="fixed-footer d-flex align-items-center justify-content-between">
            <RB.Dropdown drop="up" align="end">
              <RB.Dropdown.Toggle variant="secondary" id="actionsDrop" size="sm">
                ‚öôÔ∏è Actions
              </RB.Dropdown.Toggle>
              <RB.Dropdown.Menu className="p-3" style={{minWidth:260}}>
                <div className="mb-2">
                  <label className="d-flex align-items-center gap-2 mb-1"><strong>Columns:</strong>
                    <input type="range" min="1" max="6" value={cols} onChange={e=>setCols(Number(e.target.value))} />
                    <span className="ms-1">{cols}</span>
                  </label>
                </div>
                <RB.Dropdown.Divider />
                <div className="mb-2 d-flex gap-2 btn-group" role="group" aria-label="Theme selection">
                  <button className="btn btn-outline-secondary btn-sm" title="Light theme" onClick={()=>setTheme('light')} style={{flex:1, opacity: theme==='light' ? 1 : 0.5}}>‚òÄÔ∏è</button>
                  <button className="btn btn-outline-secondary btn-sm" title="Dark theme" onClick={()=>setTheme('dark')} style={{flex:1, opacity: theme==='dark' ? 1 : 0.5}}>üåô</button>
                </div>
                <RB.Dropdown.Divider />
                <div className="d-flex gap-2">
                  <button className="btn btn-primary btn-sm" onClick={downloadSelected}>üì• Download</button>
                  <button className="btn btn-outline-secondary btn-sm" onClick={copyToClipboard}>üìã Copy</button>
                </div>
              </RB.Dropdown.Menu>
            </RB.Dropdown>
            <div className="d-flex align-items-center gap-2">
              {selected.size > 0 ? (
                <>
                  <small className="text-muted">{selected.size} selected ‚Ä¢</small>
                  <a href="#" className="text-primary" style={{textDecoration:'underline',fontSize:'0.85rem'}} onClick={(e)=>{ e.preventDefault(); setSelected(new Set()); setLastSelectedUrl(null); }}>unselect all</a>
                </>
              ) : (
                <small className="text-muted">{folders.reduce((acc,f)=>acc+f.files.length,0)} total images</small>
              )}
            </div>
          </div>

        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  </body>
</html>